%code requires {
#include <memory>
#include <iostream>
#include <string>
#include "..\AbstractTreeGenerator\AllNodes.h"
using namespace AbstractTreeGenerator;
//using namespace std;
}

%{

#include <memory>
#include <iostream>
#include <string>
#include "..\AbstractTreeGenerator\AllNodes.h"
using namespace AbstractTreeGenerator;
//using namespace std;


int yyerror(char *s);
int yylex(void);






void DebugOutput(const std::string& s){
	std::cout << s << std::endl;
}
%}

%union{
	int int_val;
	std::string str_val;
	std::shared_ptr<CProgram> program;
	std::shared_ptr<CMainClass> mainClass;
	std::shared_ptr<CClassDeclarationList> classDeclarationList;
	std::shared_ptr<CClassDeclaration> classDeclaration;
	std::shared_ptr<CClassExtend> classExtend;
	std::shared_ptr<CVarDeclarationList> varDeclarationList;
	std::shared_ptr<CVarDeclaration> varDeclaration;
	std::shared_ptr<CMethodDeclarationList> methodDeclarationList;
	std::shared_ptr<CMethodDeclaration> methodDeclaration;
	std::shared_ptr<CType> type;
	std::shared_ptr<CNumberExpr> numExpression;
	std::shared_ptr<CExpressionList> expressionList;
	std::shared_ptr<IExpression> expression;
	std::shared_ptr<CStatementList> statementList;
	std::shared_ptr<IStatement> statement;
	std::shared_ptr<CArgumentList> argumentList;
	std::shared_ptr<CArgument> argument;
}

%start	input 

%token<int_val> T_NUM
%token<str_val> T_ID
%token T_class, T_public, T_private, T_protected, T_static, T_main,  T_extends, T_return, T_new
%token T_void, T_int, T_boolean, T_string, T_char, T_dot, T_else, T_star
%token T_lparen, T_rparen, T_lbrace, T_rbrace, T_lbracket, T_rbracket
%token T_if, T_while, T_sop, T_length, T_true, T_false, T_this
%token T_equal,  T_and, T_less, T_plus, T_minus, T_times, T_divide, T_mod, T_or
%token T_semi, T_comma, T_not

%type<program> MainProgram
%type<mainClass> MainClass
%type<classDeclarationList> ClassDeclarationList
%type<classDeclaration> ClassDeclaration
%type<classExtend> ClassExtend
%type<varDeclarationList> VarDeclarationList
%type<varDeclaration> VarDeclaration
%type<methodDeclarationList> MethodDeclarationList
%type<methodDeclaration> MethodDeclaration
%type<argumentList> ArgumentList
%type<argument> Argument
%type<type> Type
%type<statementList> StatementList
%type<statement> Statement
%type<expressionList> ExpressionList
%type<expression> Expression, Identifier

%%

input: MainProgram

MainProgram: MainClass ClassDeclarationList {
	$$ = std::shared_ptr<CProgram>(new CProgram($1, $2));
	//CProgram(MainClass, ClassDeclarationList)
}

MainClass: T_class Identifier T_lbrace
	T_public T_static T_void T_main T_lparen T_string T_lbracket T_rbracket Identifier T_rparen T_lbrace
		Statement T_rbrace
	T_rbrace {
		$$ = std::shared_ptr<CMainClass>(new  CMainClass(
			std::dynamic_pointer_cast<CIdExpression>($2), 
			std::dynamic_pointer_cast<CIdExpression>($12), 
			$15));
		// IClass(Identifier, Identifier, Statement)
		}

ClassDeclarationList:
	| ClassDeclaration ClassDeclarationList {
		$$ = std::shared_ptr<CClassDeclarationList>(new CClassDeclarationList($1, $2));
		//ClassDeclarationList(ClassDeclaration, ClassDeclarationList)
	}

ClassDeclaration: T_class Identifier ClassExtend T_lbrace
		VarDeclarationList
		MethodDeclarationList
	T_rbrace {
		$$ = std::shared_ptr<CClassDeclaration>(new CClassDeclaration(
			std::dynamic_pointer_cast<CIdExpression>($2), $3, $5, $6));
		//ClassDeclaration(Identifier, ClassExtend, VarDeclarationList, MethodList)
	}

ClassExtend:
	| T_lparen T_extends Identifier T_rparen {
		$$ = std::shared_ptr<CClassExtend>(new CClassExtend(
		std::dynamic_pointer_cast<CIdExpression>($3)));
		//ClassExtend(Identifier)
	}

VarDeclarationList:
	| VarDeclaration VarDeclarationList {
		$$ = std::shared_ptr<CVarDeclarationList>(new CVarDeclarationList($1, $2));
		//VarDeclarationList(VarDeclaration,VarDeclarationList)
	}

VarDeclaration : Type Identifier T_semi {
		$$ = std::shared_ptr<CVarDeclaration>(new CVarDeclaration(
			$1, 
			std::dynamic_pointer_cast<CIdExpression>($2)));
		//VarDeclaration(Type, Identifier)
	}

MethodDeclarationList:
	| MethodDeclaration MethodDeclarationList {
		$$ = std::shared_ptr<CMethodDeclarationList>(new CMethodDeclarationList($1, $2));
		//MethodDeclarationList(MethodDeclaration, MethodDeclarationList)
	}

MethodDeclaration: T_public Type Identifier T_lparen ArgumentList T_rparen T_lbrace
	VarDeclarationList StatementList T_return Expression T_semi T_rbrace {
		$$ = std::shared_ptr<CMethodDeclaration>(new CMethodDeclaration($2, 
		std::dynamic_pointer_cast<CIdExpression>($3), $5, $8, $9, $11));
		//MethodDeclaration(Type, Identifier, ArgumentList, VarDeclarationList, StatementList, Expression)
	}

ArgumentList:
	| Argument {
		$$ = std::shared_ptr<CArgumentList>(new CArgumentList($1, nullptr));
		//ArgumentList(Argument, nullptr)
	}
	| Argument T_comma ArgumentList {
		$$ = std::shared_ptr<CArgumentList>(new CArgumentList($1, $3));
		//ArgumentList(Argument, ArgumentList)
	 }

Argument: Type Identifier {
		$$ = std::shared_ptr<CArgument>(new CArgument(
			$1, 
			std::dynamic_pointer_cast<CIdExpression>($2)));
		//Argument(Type, Identifier)
	}

Type: T_int T_lbracket T_rbracket {
		$$ = std::shared_ptr<CType>(new CType("INTLIST"));
	}
	| T_boolean {
		$$ = std::shared_ptr<CType>(new CType("BOOL"));
	}
	| T_int {
		$$ = std::shared_ptr<CType>(new CType("INT"));
	}
	| Identifier {
		$$ = std::shared_ptr<CType>(new CType(std::dynamic_pointer_cast<CIdExpression)>($1)->GetName().c_str()));
		//Type(Identifier)
	}

StatementList:
	| Statement StatementList {
		$$ = std::shared_ptr<CStatementList>(new CStatementList($1, $2));
		//StatementList(Statement, StatementList)
	}

Statement: T_lbrace StatementList T_rbrace {
		$$ = std::shared_ptr<IStatement>(new CCompoundStatement($2));
		//CompoundStatement(StatementList)
	}
	| T_if T_lparen Expression T_rparen Statement T_else Statement {
		$$ = std::shared_ptr<IStatement>(new CConditionStatement($3, $5, $7));
		//CondtitionStatement(Expression, Statement, Statement)
	}
	| T_while T_lparen Expression T_rparen Statement {
		$$ = std::shared_ptr<IStatement>(new CPreconditionStatement(
			std::dynamic_pointer_cast<CIdExpression>($3), 
			$5));
		//PreconditionStatement(Expression, Statement)
	}
	| T_sop  T_lparen Expression T_rparen T_semi {
		$$ = std::shared_ptr<IStatement>(new CPrintStatement($3));
		//PrintStatement(Expression)
	}
	| Identifier T_equal Expression T_semi {
		$$ = std::shared_ptr<IStatement>(new CAssignmentStatement(
			std::dynamic_pointer_cast<CIdExpression>($1), 
			$3));
		//AssignmentStatement(Identifier, Expression)
	}
	| Identifier T_lbracket Expression T_rbracket T_equal Expression T_semi {
		$$ = std::shared_ptr<IStatement>(new CAssignmentListStatement(
			std::dynamic_pointer_cast<CIdExpression>($1), 
			$3, 
			$6));
		//AssignmentListStatement(Identifier, Expression, Expression)
	}

Expression: Expression T_and Expression {
		$$ = std::shared_ptr<IExpression>(new COperationExpression($1, $3, COperationExpression::TOperationType::And));
		//OperationExpression(Expression, Expression, And)
	}
	|  Expression T_less Expression {
		$$ = std::shared_ptr<IExpression>(new COperationExpression($1, $3, COperationExpression::TOperationType::Less));
		//OperationExpression(Expression, Expression, Less)
	}
	|  Expression T_plus Expression {
		$$ = std::shared_ptr<IExpression>(new COperationExpression($1, $3, COperationExpression::TOperationType::Plus));
		//OperationExpression(Expression, Expression, Plus)
	}
	|  Expression T_minus Expression {
		$$ = std::shared_ptr<IExpression>(new COperationExpression($1, $3, COperationExpression::TOperationType::Minus));
		//OperationExpression(Expression, Expression, Minus)
	}
	|  Expression T_star Expression {
		$$ = std::shared_ptr<IExpression>(new COperationExpression($1, $3, COperationExpression::TOperationType::Times));
		//OperationExpression(Expression, Expression, Times)
	}
	|  Expression T_divide Expression {
		$$ = std::shared_ptr<IExpression>(new COperationExpression($1, $3, COperationExpression::TOperationType::Divide));
		//OperationExpression(Expression, Expression, Divide)
	}
	|  Expression T_mod Expression {
		$$ = std::shared_ptr<IExpression>(new COperationExpression($1, $3, COperationExpression::TOperationType::Mod));
		//OperationExpression(Expression, Expression, Mod)
	}
	|  Expression T_or Expression {
		$$ = std::shared_ptr<IExpression>(new COperationExpression($1, $3, COperationExpression::TOperationType::Or));
		//OperationExpression(Expression, Expression, Or)
	}
	| Expression T_lbracket Expression T_rbracket {
		$$ = std::shared_ptr<IExpression>(new CIndexExpression($1, $3));
		//IndexExpression(Expression,Expression)
	}
	| Expression T_dot T_length {
		$$ = std::shared_ptr<IExpression>(new CLengthExpression($1));
		//LengthExpression(Expression)
	}
	| Expression T_dot Identifier T_lparen ExpressionList T_rparen {
		$$ = std::shared_ptr<IExpression>(new CGetFieldExpression(
			$1, 
			std::dynamic_pointer_cast<CIdExpression>($3),
			$5));
		//GetFieldExpression(Expression, Identifier, ExpressionList)
	}
	| T_NUM {
		//$$ = std::shared_ptr<IExpression>(0);
		$$ = std::shared_ptr<IExpression>(new CNumberExpr($1));
		//NumExpression(int)
	}
	| T_true {
		$$ = std::shared_ptr<IExpression>(new CTrueExpression());
	}
	| T_false {
		$$ = std::shared_ptr<IExpression>(new CFalseExpression());
	}
	| Identifier {
		$$ = std::shared_ptr<IExpression>(new CIdExpression($1));
		//IdExpression(Identifier)
	}
	| T_this {
		$$ = std::shared_ptr<IExpression>(new CThisExpression());
		//ThisExpression()
	}
	| T_new T_int T_lbracket Expression T_rbracket {
		$$ = std::shared_ptr<IExpression>(new CListConstructorExpression($4));
		//ListConstructorExpression(Expression)
	}
	| T_new Identifier T_lparen T_rparen {
		$$ = std::shared_ptr<IExpression>(new CConstructorExpression(
			std::dynamic_pointer_cast<CIdExpression>($2)));
		//ConstructorExpression(Identifier)
	}
	| T_not Expression {
		$$ = std::shared_ptr<IExpression>(new CNegationExpression($2));
		//NegationExpression(Expression)
	}
	| T_lparen Expression T_rparen {
		$$ = std::shared_ptr<IExpression>(new CParenExpression($2));
		//ParenExpression(Expression)
	}

ExpressionList:
	| Expression T_comma ExpressionList {
		$$ = std::shared_ptr<CExpressionList>(new CExpressionList($1, $3));
		//ExpressionList(Expression, ExpressionList)
	}
	| Expression {
		$$ = std::shared_ptr<CExpressionList>(new CExpressionList($1, nullptr));
		//ExpressionList(Expression, nullptr)
	}

Identifier: T_ID {
		$$ = std::shared_ptr<IExpression>(new CIdExpression($1));
		//IdExpression(string);
	}


%%

int yyerror(std::string s) {
  extern int yylineno;	// defined and maintained in lex.c
  extern char *yytext;	// defined and maintained in lex.c
  
  std::cerr << "ERROR: " << s << " at symbol \"" << yytext;
  std::cerr << "\" on line " << yylineno << std::endl;
  exit(1);
}

int yyerror(char *s) {
	return yyerror(std::string(s));
}

